# Problem-solving


# DFS tasks 


### [Connectivity Components](./CPPSolving/СonnectivityСomponents.cpp)

Дан неориентированный невзвешенный граф. Необходимо посчитать количество его компонент связности и вывести их

### [Check Tree](./CPPSolving/CheckTree.cpp)

Дан неориентированный граф из N вершин и M ребер. Необходимо проверить, является ли граф деревом. Дерево — это связный граф без циклов.

### [Bypass](./CPPSolving/Bypass.cpp)

Пошаговым обходом графа из вершины v назовём последовательность вершин u1, u2,…,ur  u1, u2,…,ur такую, что: u1 = ur = u,
Каждая вершина графа, достижимая из v, встречается в ней хотя бы один раз, и Между любыми двумя соседними вершинами последовательности в графе существует ребро.
Задан связный неориентированный граф и его вершина v. Выведите любой пошаговый обход этого графа.

### [Cycle](./CPPSolving/Cycle.cpp)

Дан ориентированный невзвешенный граф. Необходимо определить есть ли в нём циклы, и если есть, то вывести любой из них

### [City](./CPPSolving/City.cpp)

Дорожная сеть в Байтландии обладает следующими свойствами:
Неориентированность: На всех дорогах движение является двусторонним.
Связность: Из любого города Байтландии можно проехать в любой другой по сети дорог.
Отсутствие циклов: Между любыми двумя городами Байтландии существует ровно один путь.
Назовём удалённостью города максимум из расстояний от него до других городов. Требуется найти все города с минимальной удалённостью

### [Bridge](./CPPSolving/Bridge.cpp)

Всем известно, что Санкт-Петербург состоит из множества островов. Некоторые из них соединены мостами. Известно, что из любого острова можно попасть на любой другой. 
Опасность составляют те мосты, при разрушении каждого из которых существуют два острова, таких что из одного нельзя попасть в другой. Передвигаться по мосту можно в обе стороны.

### [Articulation](./CPPSolving/Articulation.cpp)

Дан неориентированный граф без петель и кратных рёбер. Требуется найти все точки сочленения в нем.

### [Magnetic pillows](./CPPSolving/MagneticPillows.cpp)

Город будущего застроен небоскребами, для передвижения между которыми многие тройки небоскребов соединены треугольной подушкой из однополярных магнитов. 
Каждая подушка соединяет ровно 3 небоскреба и вид сверху на нее представляет собой треугольник, с вершинами в небоскребах. Это позволяет беспрепятственно передвигаться между соответствующими небоскребами. 
Подушки можно делать на разных уровнях, поэтому один небоскреб может быть соединен различными подушками с парами других, причем два небоскреба могут соединять несколько подушек (как с разными третьими небоскребами, так и с одинаковым). Например, возможны две подушки на разных уровнях между небоскребами 1, 2 и 3, и, кроме того, магнитная подушка между 1, 2, 5.
Система магнитных подушек организована так, что с их помощью можно добираться от одного небоскреба, до любого другого в этом городе (с одной подушки на другую можно перемещаться внутри небоскреба), но поддержание каждой из них требует больших затрат энергии.
Требуется написать программу, которая определит, какие из магнитных подушек нельзя удалять из подушечной системы города, так как удаление даже только этой подушки может привести к тому, что найдутся небоскребы из которых теперь нельзя добраться до некоторых других небоскребов, и жителям станет очень грустно.

### [Flounder](./CPPSolving/Flounder.cpp)

В Байтландии существуют n городов, соединённых n−1 дорогами с двусторонним движением таким образом, что из каждого города можно проехать в любой другой по сети дорог. Длина каждой дороги равна 1 километру.
Бензобак автомобиля позволяет проехать без заправки m километров. Требуется выбрать маршрут, позволяющий посетить наибольшее количество различных городов без дозаправки. При этом начинать и заканчивать маршрут можно в произвольных городах.

### [Red-Blue graph](./CPPSolving/RedGraph.cpp)

Даны N точек, занумерованных числами 1, 2, ..., N. От каждой точки с меньшим номером к каждой точке с большим номером ведет стрелка красного или синего цвета. Раскраска стрелок называется однотонной, если нет двух таких точек A и B, что от A до B можно добраться как только по красным стрелкам, так и только по синим.
Ваша задача — по заданной раскраске определить, является ли она однотонной.


# Shortest path algorithms


### [Islands](./CPPSolving/Islands.cpp) 

Суровые феодальные времена переживала некогда великая островная страна Байтландия. За главенство над всем островом борются два самых сильных барона. Таким образом, каждый город страны контролируется одним из правителей. Как водится издревле, некоторые из городов соединены двусторонними дорогами. 
Бароны очень не любят друг друга и стараются делать как можно больше пакостей. В частности, теперь для того чтобы пройти по дороге, соединяющей города различных правителей, надо заплатить пошлину — один байтландский рубль.
Программист Вася живет в городе номер 1. С наступлением лета он собирается съездить в город  N на Всебайтландское сборище программистов. Разумеется, он хочет затратить при этом как можно меньше денег и помочь ему здесь, как обычно, предлагается Вам.

### [Dijkstra Path](./CPPSolving/DijkstraPath.cpp)

Дан ориентированный взвешенный граф. Найдите кратчайший путь от одной заданной вершины до другой

### [Electrobus](./CPPSolving/Electrobus.cpp)

Между некоторыми корпусами НИУ ВШЭ, ходят электробусы. Электробусы ходят всего несколько раз в день.
Эшли требуется добраться к Нареку из корпуса D в корпус V как можно быстрее (считается, что в момент времени 0 она находится в корпусе D). 
Сначала вводится число N — общее число корпусов (1≤N≤100), затем номера корпусов D и V, за ними следует количество автобусных рейсов R (0≤R≤10^4). Далее идут описания автобусных рейсов. Каждый рейс задается номером корпуса отправления, временем отправления, корпусом назначения и временем прибытия (все времена – целые от 0 до 10^4). 
Если в момент t пассажир приезжает в какой-то корпус, то уехать из него он может в любой момент времени, начиная с t.

### [Cup](./CPPSolving/Cup.cpp)

К Междупланетному Шахматному Конгрессу, который, как известно, проходит в городе Нью-Васюки, было решено подготовить памятные кружки для всех участников и болельщиков.
Имея привычку делать важные дела в самый последний момент, дизайнер закончил работу над макетом за два дня до начала школы. Ещё день уйдёт у завода-изготовителя на то, чтобы изготовить кружки и нанести на них изображение. На то, чтобы довезти кружки от завода-изготовителя до Нью-Васюков, остаётся всего 24 часа.
Заказ на 10^7 экземпляров кружек (а именно столько заказали организаторы), конечно же, за один рейс не увезти. Однако, за первый рейс хочется привезти максимальное количество кружек. Для перевозки был заказан один большегрузный автомобиль. Но есть один нюанс: на некоторых дорогах установлено ограничение на вес автомобиля. Поэтому если автомобиль нагрузить кружками под завязку, то, возможно, не удастся воспользоваться самым коротким маршрутом, а придётся ехать в объезд. Может случиться даже так, что из-за этого грузовик не успеет доехать до Нью-Васюков вовремя, а этого допустить никак нельзя.
Итак, сколько же кружек можно погрузить в автомобиль, чтобы успеть привезти этот ценный груз вовремя, не нарушая правил дорожного движения?

### [Bellman-Ford](./CPPSolving/Bellman-Ford.cpp)

Дан ориентированный граф, в котором могут быть кратные ребра и петли. Каждое ребро имеет вес, выражающийся целым числом (возможно, отрицательным). Гарантируется, что циклы отрицательного веса отсутствуют.
Требуется посчитать длины кратчайших путей от вершины номер 1 до всех остальных вершин.

### [Floyd](./CPPSolving/Floyd.cpp) 

Полный ориентированный взвешенный граф задан матрицей смежности. Постройте матрицу кратчайших путей между его вершинами.
Гарантируется, что в графе нет циклов отрицательного веса.

### [Shortest Path](./CPPSolving/ShortestPath.cpp)

Дан взвешенный ориентированный граф и вершина s в нем. Требуется для каждой вершины u найти длину кратчайшего пути из s в u.
Первая строка входного файла содержит n, m и s — количество вершин, ребер и номер выделенной вершины соответственно (2≤n≤2000, 1≤m≤6000).
Следующие m строк содержат описание ребер. Каждое ребро задается стартовой вершиной, конечной вершиной и весом ребра. Вес каждого ребра — целое число, не превосходящее 10^15 по модулю. В графе могут быть кратные ребра и петли.


# Geometric, DSU, others


### [Convex Hull](./CPPSolving/ConvexHull.cpp)

На плоскости даны N точек. Вам требуется построить выпуклую оболочку данного множества точек. 
Выведите два числа: периметр и площадь.

### [DSU](./CPPSolving/DSU.cpp)

Напишите программу, которая будет содержать реализацию структуры данных для совокупности непересекающихся подмножеств (disjoint sets) и обрабатывать запросы таких видов:
RESET n — создать новую серию подмножеств: множество из одного только элемента 0, из одного только элемента 1, и так до множества из одного только элемента n–1 включительно. Если структура уже содержала какую-то другую совокупность непересекающихся подмножеств, вся соответствующая информация утрачивается. На стандартный выход (экран) при этом следует вывести два слова через пробел «RESET DONE».
JOIN j k — объединить подмножества, которым принадлежат элемент j и элемент k. Если элементы и так принадлежали одному подмножеству, вывести на стандартный выход (экран) слово «ALREADY», после него через пробелы те же числа j и k в том же порядке. Если элементы до сих пор принадлежали разным подмножествам, то действие происходит только с данными в памяти, на экран ничего не выводится.
CHECK j k — проверить, одному ли подмножеству принадлежат элемент j и элемент k; вывести на стандартный выход (экран) слово «YES» (если одному) или слово «NO» (если разным).

### [Kruskal](./CPPSolving/Kruskal.cpp)

Напишите программу, которая будет либо находить вес остовного дерева минимального веса неориентированного взвешенного графа без петель с положительными длинами ребер, либо устанавливать, что введённый граф несвязный


# Segment tree tasks


### [GCD](./CPPSolving/STgcd.cpp) 

Реализуйте эффективную структуру данных, позволяющую изменять элементы массивы и вычислять НОД нескольких подряд идущих элементов.

### [Sum + change element](./CPPSolving/STsum.cpp) 

Дан массив из N элементов, нужно научиться находить сумму чисел на отрезке

### [Max](./CPPSolving/STmax.cpp) 

Реализуйте эффективную структуру данных для хранения массива и выполнения следующих операций: увеличение всех элементов данного отрезка на одно и то же число; поиск максимума на отрезке

### [Alternation](./CPPSolving/Alternation.cpp)

Реализуйте структуру данных из 
n элементов a1, a2… an, поддерживающую следующие операции: присвоить элементу  ai значение j;
найти знакочередующуюся сумму на отрезке от l до r включительно (al−a(l+1)+a(l+2)−…±aral−a(l+1)+a(l+2)−…±ar).


# LCA and Treap


### [LCA](./CPPSolving/LCA.cpp)

Задано подвешенное дерево, содержащее n (1 ≤n ≤ 100000) вершин, пронумерованных от 0 до п - 1.
Требуется ответить на т (1 ≤ m ≤ 100000) запросов о наименьшем общем предке для пары вершин.
Запросы генерируются следующим образом. Заданы числа а [11, а [2] и числа х, у и z.
Числа а [3], ..., а [2m] генерируются следующим образом: (a[i]=x*a[i- 2]+y*a[i - 1]+z) modn.
Первый запрос имеет вид (а [1], а [2]). Если ответ на (і - 1)-й запрос равен v, то і-й запрос имеет вид ((
a[2i - 1]+v) modn, a [2i]).

### [LCA min](./CPPSolving/LCAmin.cpp)

Дано подвешенное дерево с корнем в первой вершине. Все ребра имеют веса (стоимости). Вам нужно ответить на M запросов вида “найти у двух вершин минимум среди стоимостей ребер пути между ними”.

### [Treap with explicit key](./CPPSolving/TreapExplicit.cpp) 

Реализуйте сбалансированное двоичное дерево поиска

### [Treap with implicit key](./CPPSolving/TreapImplicit.cpp) 

Научитесь быстро делать две операции с массивом:
∘ add i x — добавить после i-го элемента x (0≤i≤n)
∘ del i — удалить i-й элемент (1≤i≤n)

### [Treap + segment tree sum](./CPPSolving/TreapSum.cpp) 

Реализуйте структуру данных, которая поддерживает множество S целых чисел, с кото- ром разрешается производить следующие операции:
∙ add(i) — добавить в множество S число i (если он там уже есть, то множество не меняется);
∙ sum(l, r) — вывести сумму всех элементов x из S , которые удовлетворяют неравенству l≤x≤r.
